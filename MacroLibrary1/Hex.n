using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MacroLibrary1
{
    public macro sha1(str) {
        HexImpl.Transform(Macros.ImplicitCTX(), 40, str)
    }

    module HexImpl
    {
        public Transform(typer: Typer, length: byte, str: PExpr) : PExpr
        {
            Macros.DefineCTX(typer);
            match (str) {
             | <[ $(s: string) ]> => 
                def allowedChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
                if (s.Length :> byte != length) {
                    Message.Error($"Expecting string of size $length.");
                    <[]>
                }
                else if (!s.ForAll(allowedChars.Contains)) {
                    Message.Error("Expecting hex string.");
                    <[]>
                }
                else 
                {
                    <[
                        def stringToByteArray(hex: string) {
                            $[0..hex.Length - 1]
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray()
                        }
                        
                        stringToByteArray($s);
                    ]>
                }
             | expr => throw Exception($"Expected hex string, but got $expr.");
            }
        }
    }
}
